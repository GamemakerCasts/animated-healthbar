function HealthBar(_x, _y, _w, _h, _max_hp) constructor
{
    static TextType = { NONE:0, PERCENT:1, FRACTION:2 };
    static Alignment = { LEFT:0, RIGHT:1 };

    // Position & Size
    __x = _x; __y = _y; __w = _w; __h = _h;
    __pad = 2;

    // Health tracking
    max_hp    = _max_hp;
    hp_target = _max_hp;
    hp_visual = _max_hp;
    hp_chip   = _max_hp;

    // Animation
    lerp_speed  = 0.22;
    chip_speed  = 0.08;
    flash_time  = 0;
    flash_max   = 10;
    shake_timer = 0;
    shake_amt   = 2;

    // Healing FX
    heal_pulse_time = 0;
    heal_pulse_max  = 12;
    heal_gain_time  = 10;
    heal_gain_max   = 30;
    heal_start_pct  = 0;

    // Text
    text_mode      = TextType.NONE;
    text_align     = Alignment.RIGHT;
    text_pad       = 8;
    text_color     = c_white;
    text_precision = 0;
    text_font      = -1;

    // Surface Cache
    __surf  = -1;
    __dirty = true;
    __sw = 0; __sh = 0;

    // Label Cache
    __label = ""; // what we actually draw
    __label_last_key = ""; // compact key to detect when label should change

    // Internal helpers
    __epsilon = 0.001;

    __approx = function(a, b) {
		return abs(a - b) < __epsilon;
	};
	
    __mark_dirty = function() {
		__dirty = true;
	};

    // Create a compact "key" that changes only when the visible label
	// should change. We key off hp_visual rounded to match
	// the label’s display precision.
    __make_label_key = function() {
        if (text_mode == TextType.NONE) return "|none|";

        switch (text_mode) {
            case TextType.PERCENT:
            {
                var pct = clamp(hp_visual / max_hp, 0, 1) * 100;
                // Round to visible precision
                var factor = power(10, max(0, text_precision));
                var r = round(pct * factor) / factor;
                return "|pct|" + string(r) + "|" + string(text_precision);
            }
            case TextType.FRACTION:
            {
                // Integer style – use round on visual HP to prevent twitching
                var vis = round(hp_visual);
                return "|frac|" + string(vis) + "|" + string(max_hp);
            }
        }
        return "|?";
    };

    __build_label_from_key = function(key) {
        if (text_mode == TextType.NONE) { __label = ""; return; }

        switch (text_mode) {
            case TextType.PERCENT:
            {
                var pct = clamp(hp_visual / max_hp, 0, 1) * 100;
                // Use string_format to the requested decimals; but the key ensures we only
                // redraw when that rounded value changes.
                __label = string_format(pct, 0, text_precision) + "%";
            } break;

            case TextType.FRACTION:
            {
                var vis_int = round(hp_visual);
                __label = string(vis_int) + " / " + string(max_hp);
            } break;
        }
    };

    __ensure_surface = function() {
        var want_w = __w + __pad * 2;
        var want_h = __h + __pad * 2;

        if (!surface_exists(__surf) || __sw != want_w || __sh != want_h) {
            if (surface_exists(__surf)) surface_free(__surf);
            __surf = -1;

            if (want_w > 0 && want_h > 0) {
                __surf = surface_create(want_w, want_h);
                __sw = want_w; __sh = want_h;
                __dirty = true;
            }
        }
    };

    __render_to_surface = function() {
        if (!surface_exists(__surf)) return;

        var pct_target = clamp(hp_target / max_hp, 0, 1);
        var pct_visual = clamp(hp_visual / max_hp, 0, 1);
        var pct_chip   = clamp(hp_chip   / max_hp, 0, 1);

        var bg_col   = make_color_rgb(30,30,35);
        var chip_col = make_color_rgb(180,40,40);
        var heal_col = make_color_rgb(40,220,170);
        var fg_col   = merge_color(c_red, c_lime, pct_target);

        surface_set_target(__surf);
        draw_clear_alpha(c_black, 0);

        var ox = __pad, oy = __pad;

        // Background
        draw_set_color(bg_col);
        draw_rectangle(ox, oy, ox + __w, oy + __h, false);

        // Damage chip
        draw_set_color(chip_col);
        draw_rectangle(ox, oy, ox + __w * pct_chip, oy + __h, false);

        // Heal gain segment
        if (heal_gain_time > 0 && pct_visual > heal_start_pct) {
            var x0 = ox + __w * heal_start_pct;
            var x1 = ox + __w * pct_visual;

            draw_set_color(heal_col);
            draw_rectangle(x0, oy, x1, oy + __h, false);

            draw_set_alpha(heal_gain_time / heal_gain_max * 0.6);
            var stripe_w = 6;
            for (var i = floor(x0); i < x1; i += stripe_w * 2) {
                draw_rectangle(i, oy, i + stripe_w, oy + __h, false);
            }
            draw_set_alpha(1);
        }

        // Main fill
        draw_set_color(fg_col);
        draw_rectangle(ox, oy, ox + __w * pct_target, oy + __h, false);

        // Heal pulse glow
        if (heal_pulse_time > 0) {
            var t = heal_pulse_time / heal_pulse_max;
            draw_set_alpha(t * 0.6);
            draw_set_color(heal_col);
            draw_rectangle(ox - 2, oy - 2, ox + __w + 2, oy + __h + 2, false);
            draw_set_alpha(1);
        }

        // Damage flash
        if (flash_time > 0) {
            draw_set_alpha(flash_time / flash_max);
            draw_set_color(c_white);
            draw_rectangle(ox, oy, ox + __w, oy + __h, false);
            draw_set_alpha(1);
        }

        // Border
        draw_set_color(c_black);
        draw_rectangle(ox, oy, ox + __w, oy + __h, true);

        // Text (uses cached label)
        if (text_mode != TextType.NONE && __label != "") {
            var old_font = draw_get_font();
            if (text_font != -1) draw_set_font(text_font);

            var tw = string_width(__label);
            var th = string_height(__label);

            var tx = (text_align == Alignment.RIGHT)
                   ? (ox + __w + text_pad)
                   : (ox - text_pad - tw);
            var ty = oy + (__h - th) * 0.5;

            draw_set_color(text_color);
            draw_text(tx, ty, __label);

            if (text_font != -1) draw_set_font(old_font);
        }

        surface_reset_target();
        __dirty = false;
    };

    // Public setters (mark dirty)
    setTextMode = function(_mode) {
        text_mode = _mode;
        __label_last_key = ""; // force rebuild next update
        __mark_dirty();
    };
    setTextAlign= function(_align)   {
		text_align = _align; __mark_dirty();
	};
	
    setTextPad  = function(_padding) {
		text_pad   = _padding; __mark_dirty();
	};
	
    setTextFont = function(_font)    {
		text_font  = _font; __mark_dirty();
	};
	
    setTextColor= function(_color)   {
		text_color = _color; __mark_dirty();
	};
		
    setTextPrecision = function(_p)  {
        text_precision = _p;
        __label_last_key = ""; // precision affects rounding
        __mark_dirty();
    };

    // Optional: move/resize
    setPos = function(nx, ny) {
		__x = nx;
		__y = ny;
	};
	
    setSize= function(nw, nh) {
		__w = nw;
		__h = nh;
		__mark_dirty();
	};

    // Methods
    set = function(value) {
        var nv = clamp(value, 0, max_hp);
        if (!__approx(nv, hp_target)) {
            hp_target = nv;
            __mark_dirty();
        }
    };

    damage = function(amount) {
        set(hp_target - amount);
        flash_time  = flash_max;
        shake_timer = 6;
        __mark_dirty();
    };

    heal = function(amount) {
        var prev_pct = hp_visual / max_hp;
        set(hp_target + amount);

        heal_start_pct  = prev_pct;
        heal_pulse_time = heal_pulse_max;
        heal_gain_time  = heal_gain_max;
        __mark_dirty();
    };

    update = function() {
        var prev_visual = hp_visual;
        var prev_chip   = hp_chip;
        var prev_flash  = flash_time;
        var prev_pulse  = heal_pulse_time;
        var prev_gain   = heal_gain_time;

        // Smooth bar toward target
        hp_visual = lerp(hp_visual, hp_target, lerp_speed);

        // Chip trail only if taking damage
        if (hp_chip > hp_visual) {
            hp_chip = lerp(hp_chip, hp_visual, chip_speed);
        } else {
            hp_chip = hp_visual;
        }

        // Timers
        if (flash_time > 0)      flash_time--;
        if (shake_timer > 0)     shake_timer--;
        if (heal_pulse_time > 0) heal_pulse_time--;
        if (heal_gain_time > 0)  heal_gain_time--;

        // Bar visuals change?
        if (!__approx(prev_visual, hp_visual)
        ||  !__approx(prev_chip,   hp_chip)
        ||  prev_flash != flash_time
        ||  prev_pulse != heal_pulse_time
        ||  prev_gain  != heal_gain_time) {
            __mark_dirty();
        }

        // Label update (only when rounded visual changes)
        // Build a key from the rounded hp_visual
		// (based on text_mode/precision)
        var new_key = __make_label_key();
        if (new_key != __label_last_key) {
            __label_last_key = new_key;
            __build_label_from_key(new_key);
            __mark_dirty(); // label text/width may have changed
        }
    };

    draw = function() {
        __ensure_surface();

        if (__dirty && surface_exists(__surf)) {
            __render_to_surface();
        }

        var sx = (shake_timer > 0) ? irandom_range(-shake_amt, shake_amt) : 0;
        var sy = (shake_timer > 0) ? irandom_range(-shake_amt, shake_amt) : 0;

        if (surface_exists(__surf)) {
            draw_surface(__surf, __x - __pad + sx, __y - __pad + sy);
        } else {
            __mark_dirty();
        }
    };

    destroy = function() {
        if (surface_exists(__surf)) surface_free(__surf);
        __surf = -1;
    };
}
